:spring-fu-version: 0.5.0
:kofu-kdoc-url: http://repo.spring.io/milestone/org/springframework/fu/spring-fu-kofu/{spring-fu-version}/spring-fu-kofu-{spring-fu-version}-javadoc.jar!

image:https://img.shields.io/badge/KoFu%20documentation-blue.svg["KoFu documentation", link="{kofu-kdoc-url}/kofu/index.html"]

== KoFu DSL for Spring Boot

KoFu (for **Ko**tlin and **Fu**nctional) is an alternative way of configuring explicitly your Spring Boot application,
different from regular auto-configuration, using a Kotlin DSL. It is based on Spring Boot infrastructure, but
https://github.com/spring-projects/spring-fu/tree/main/autoconfigure-adapter[used via functional bean definitions]
instead of JavaConfig.

It leverages other Spring Kotlin DSLs available in Spring like:

* https://docs.spring.io/spring/docs/current/spring-framework-reference/languages.html#kotlin-bean-definition-dsl[`beans { }` DSL] from Spring Framework
* https://docs.spring.io/spring/docs/current/spring-framework-reference/languages.html#router-dsl[`router { }` DSL] from Spring MVC or Spring WebFlux
* https://github.com/spring-projects-experimental/spring-security-kotlin-dsl[`security { }` DSL] (work in progress) from Spring Security

=== Differences with regular Boot applications

- Spring optimizations for native applications are enabled by default
- XML support is disabled by default
- SpEL support is disabled by default
- Devtools automatic restart does not work yet so just restart your applications (very fast with KoFu)

== Content of this tutorial

We are going to build the same blog application as https://spring.io/guides/tutorials/spring-boot-kotlin/[the tutorial for writing Spring Boot applications in Kotlin].

Instead of Spring Data JPA, we are going to use plain JDBC, in order to avoid completely the use of CGLIB.
Writing repositories in plain JDBC requires a consistent extra effort. Fortunately, there exist light ORM like
https://github.com/JetBrains/Exposed[Jetbrains Exposed] or https://www.jooq.org/[Jooq], that are an excellent trade-off
between the productivity of JPA and the readability/testability of plain JDBC. But those are out of the scope of this tutorial.

We will see how KoFu enhances the testability of our code, removing the "magics" of annotations autowiring, and giving you back
the full control of the dependency injection context.

In the end we will see an example of how to plugin-in modules that are not yet fully supported like https://liquibase.org/[Liquibase].

== Getting started
Click https://start.spring.io/#!type=gradle-project&language=kotlin&platformVersion=2.6.3&packaging=jar&jvmVersion=11&groupId=com.example&artifactId=blog&name=blog&description=&packageName=com.example.blog&dependencies=web,mustache,jdbc,h2[here] to go to a preconfigured Spring Initializer

We selected:

1. Gradle (Kotlin DSL) as the build system and Kotlin as language.
2. The latest stable Spring Boot `2.6.x` version (2.6.3 at the moment of writing).
3. Changed the name of artifact to "blog"
4. Jar packaging and Jvm 11 target
5. The following dependencies:
    * Spring Web
    * Mustache
    * Jdbc API
    * H2 in-memory Database

The zip contains a regular spring application template. Unpack and open it with the IDE of your choice (here we are going to use IntelliJ).

=== Modify the Gradle and Maven builds

Go to `build.gradle.kts` (Gradle) or `pom.xml` (Maven). If you don't know their content, you can refer to the sections "Understanding the Gradle Build" or "Understanding the Maven Build" of https://spring.io/guides/tutorials/spring-boot-kotlin/#understanding-generated-app[this] other tutorial.

==== Repositories

Add the spring milestone repository.

===== Gradle

[source,kotlin]
----
repositories {
    maven {
        url = uri("https://repo.spring.io/milestone")
    }
    mavenCentral()
}
----

===== Maven

[source,xml]
----
<repositories>
    <repository>
        <id>spring-milestone</id>
        <name>spring milestone</name>
        <url>https://repo.spring.io/milestone</url>
    </repository>
</repositories>
----

==== Dependencies

Add the Kofu dependency. At the time of writing the latest version of KoFu is the `0.5.0`.

===== Gradle

[source,kotlin]
----
dependencies {
    ...
    implementation("org.springframework.fu:spring-fu-kofu:$kofuVersion")
    ...
}
----

===== Maven

[source,xml]
----
<dependency>
    <groupId>org.springframework.fu</groupId>
    <artifactId>spring-fu-kofu</artifactId>
    <version>${kofu.version}</version>
</dependency>
----

==== Remove plugins (optional)

Let's remove what we don't need anymore. With KoFu, there are no more GCLIB proxies in place, then we don't need to `open` the classes of our beans (classes are `final` by default in Kotlin).

Then we can remove the unnecessary plugins.

===== Gradle

Open  `build.gradle.kts` and remove the following line:

[source,kotlin]
----
kotlin("plugin.spring") version "1.4.32"
----

The plugin section should look like this:

[source,kotlin]
----
plugins {
    id("org.springframework.boot") version "2.6.3"
    id("io.spring.dependency-management") version "1.0.11.RELEASE"
    kotlin("jvm") version "1.6.10"
}
----

===== Maven

Remove the marked lines from your `pom.xml`

[source,xml]
----
<plugins>
  <plugin>
    <groupId>org.jetbrains.kotlin</groupId>
    <artifactId>kotlin-maven-plugin</artifactId>
    <configuration>
      <compilerPlugins>           <!-- REMOVE THIS -->
        <plugin>spring</plugin>   <!-- REMOVE THIS -->
      </compilerPlugins>          <!-- REMOVE THIS -->
      <args>
        <arg>-Xjsr305=strict</arg>
      </args>
    </configuration>
    <dependencies>
      <dependency>                                    <!-- REMOVE THIS -->
        <groupId>org.jetbrains.kotlin</groupId>       <!-- REMOVE THIS -->
        <artifactId>kotlin-maven-allopen</artifactId> <!-- REMOVE THIS -->
        <version>${kotlin.version}</version>          <!-- REMOVE THIS -->
      </dependency>                                   <!-- REMOVE THIS -->
    </dependencies>
  </plugin>
</plugins>
----

The plugin section should look like this:

[source,xml]
----
<plugins>
    <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
    </plugin>
    <plugin>
        <groupId>org.jetbrains.kotlin</groupId>
        <artifactId>kotlin-maven-plugin</artifactId>
        <version>${kotlin.version}</version>
        <configuration>
            <jvmTarget>11</jvmTarget>
            <args>
                <arg>-Xjsr305=strict</arg>
            </args>
        </configuration>
    </plugin>
</plugins>
----

=== Modify The generated application

Go to `BlogApplication.kt` and modify its content as follows:

`src/main/kotlin/com/example/blog/BlogApplication.kt`

[source,kotlin]
----
package com.sample.blog

import org.springframework.fu.kofu.webApplication
import org.springframework.fu.kofu.webmvc.webMvc

val app = webApplication {
    webMvc {
    }
}

fun main(args: Array<String>) {
    app.run(args)
}
----

== Writing your first route

Let's write the routing to display a simple web page

`src/main/kotlin/com/example/blog/BlogApplication.kt`

[source,kotlin]
----
val app = webApplication {
    webMvc {
        mustache()

        router {
            GET("/"){
                ServerResponse.ok()
                    .render("blog", mapOf("title" to "Blog"))
            }
        }
    }
}

fun main(args: Array<String>) {
    app.run(args)
}
----
Notice that the `render` method doesn't use a `Model` class but just a `Map<String, Any>`.

Also, we are explicitly declaring the use of `mustache` through the activation function call. KoFu doesn't start things automatically. We have to
declare it. The cool part is that you can explore all the possible configuration options using the IDE code completion.

image::images/code_completion.png[width=500]

For example, here we see that mustache has two properties: `prefix` and `suffix`, to change the directory of the templates and the templates
extension, respectively. To test this feature, instead of using the default templates folder `classpath:/templates/`, we are going to change
it to `classpath:/views/`

`src/main/kotlin/com/example/blog/BlogApplication.kt`

[source,kotlin]
----
val app = webApplication {
    webMvc {
        mustache{
            prefix = "classpath:/views/"
        }
        ...
    }
}
----

In the `views` folder we create the following template:

`src/main/resources/views/blog.mustache`

[source,html]
----
<html>
    <head>
        <title>{{title}}</title>
    </head>
    <body>
        <h1>{{title}}</h1>
    </body>
</html>
----

Start the web application by running the main function of BlogApplication.kt, and go to http://localhost:8080/,
you should see a sober web page with a "Blog" headline.

== Testing with JUnit5

Compared to regular Spring Boot, where you have to use the annotion `@SpringBootTest`, there is nothing fancy to do
with a KoFu test. You write a normal test, and start/stop spring in the `@BeforeAll` and `@AfterAll`. It is a
regular JUnit test.

`src/test/kotlin/com/example/blog/BlogTests.kt`

[source,kotlin]
----
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class BlogTests {
    lateinit var context: ConfigurableApplicationContext
    lateinit var client: MockMvc

    @BeforeAll
    internal fun setUp() {
        val port = (10000..10500).random()

        context = app.run(arrayOf("--spring.port=${port}"))
        client = MockMvcBuilders
            .webAppContextSetup(context as WebApplicationContext)
            .build()
    }

    @AfterAll
    internal fun tearDown() {
        context.close()
    }

    @Test
    internal fun `Assert blog page title, content and status code`() {
        client.get("/")
            .andExpect {
                status { isOk() }
                content {
                    string(Matchers.containsString("<h1>Blog</h1>"))
                }
            }
    }
}
----

There is no magic here. Everything is transparent.

`@TestInstance(TestInstance.Lifecycle.PER_CLASS)` is related to JUnit 5, you
probably already know what it is if you use JUnit 5. https://www.baeldung.com/junit-testinstance-annotation[It is needed to use `@BeforeAll` and `@AfterAll`] annotations.
You can change the tests instances lyfe cycle also project-wise if you like it, as described https://github.com/spring-guides/tut-spring-boot-kotlin#test-instance-lifecycle[here].
I would not suggest of doing it.

In the `@BeforeAll` we start Spring on a random port and use the application context to create the MockMvc, so that
it points to correct port.

We then use the `client` to perform the http requests in the test and verify the result. More on MockMvc https://www.baeldung.com/integration-testing-in-spring[here].

== Write some extension utilities

We are going to write some extension utilities that we will use in the next section.

`src/main/kotlin/com/example/blog/extensions.kt`

[source,kotlin]
----
fun LocalDateTime.format(): String = this.format(englishDateFormatter)

private val daysLookup = (1..31).associate { it.toLong() to getOrdinal(it) }

private val englishDateFormatter = DateTimeFormatterBuilder()
    .appendPattern("yyyy-MM-dd")
    .appendLiteral(" ")
    .appendText(ChronoField.DAY_OF_MONTH, daysLookup)
    .appendLiteral(" ")
    .appendPattern("yyyy")
    .toFormatter(Locale.ENGLISH)

private fun getOrdinal(n: Int) = when {
    n in 11..13 -> "${n}th"
    n % 10 == 1 -> "${n}st"
    n % 10 == 2 -> "${n}nd"
    n % 10 == 3 -> "${n}rd"
    else -> "${n}th"
}

fun String.toSlug() = lowercase()
    .replace("\n", " ")
    .replace("[^a-z\\d\\s]".toRegex(), " ")
    .split(" ")
    .joinToString("-")
    .replace("-+".toRegex(), "-")
----

== Persistence with JDBC

KoFu doesn't make use of CGLIB. This means that we have to write our repository and map our entities manually. Also mastering JPA
implementations, like Hibernate, is not easy like it seems.

ORM frameworks forces you to model your entities as a 1:1 mapping with the E/R schema of the database. This could lead to design problems like:

 * http://hibernate.org/orm/what-is-an-orm/[Object-Relational impedance mismatch]
 * https://martinfowler.com/bliki/AnemicDomainModel.html[Anemic Domain Model]
 * https://refactoring.guru/smells/primitive-obsession[Primitive obsession coding smell]

Let's model our domain entities at first:

=== Domain Entities

`src/main/kotlin/com/example/blog/entities.kt`

[source,kotlin]
----
sealed class Entity<out T>{
    data class WithId<out T>(val id: Id<Long>, val info: T) : Entity<T>()
    data class New<out T>(val info: T) : Entity<T>()
}

data class Id<T>(val value: T)

data class Name(
    val firstname: String,
    val lastname: String,
)

@JvmInline
value class Login private constructor(val value: String){
    companion object{
        fun of(value: String): Login{
            require(value.isNotEmpty()){ "can't accept an empty login value" }
            return Login(value)
        }
    }
}

data class User(
    val login: Login,
    val name: Name,
    val description: String? = null){

    companion object{
        fun of(
            login: String,
            firstname: String,
            lastname: String,
            description: String? = null) =
            User(Login.of(login), Name(firstname, lastname), description)
    }
}

data class Article(
    val title: String,
    val headline: String,
    val content: String,
    private val authorFn: () -> UserEntity,
    val slug: String = title.toSlug(),
    val addedAt: LocalDateTime = LocalDateTime.now().withNano(0)
){
    val author by lazy(authorFn)
}

typealias UserEntity = Entity.WithId<User>
typealias ArticleEntity = Entity.WithId<Article>
----

Please notice the typealiases at the end. With the `typealias` we specify a more readable name to use for the entities.

Here we also used some of the many nice features of Kotlin.

===== Sealed class for the Entity

When you use a repository to save an entity, you usually don't make distinction beetween saving something new or doing an update.
This is a responsibility of the repository. Also, it happens many times that you want the persistence layer to give you
back a generated ID. There exist some strategies to model this: the most naive is to reserve some values (like 0 or negatives) to
express the intent of requesting a generated ID.

This is a perfect use-case for the https://kotlinlang.org/docs/sealed-classes.html[sealed classes] of Kotlin. We use a generic `Entity<T>`
class that is inherited by `Entity<T>.New` and `Entity<T>.WithId`. Then you can say that a repository accepts an `Entity<T>` when it
comes to the `save` method, and it returns an `Entity<T>.WithId` for the `get/find` methods. Internally the `save` method will check
statically if we are saving something new or to update.

===== Value class and companion objects for the Login and the User

A login value is not just a string. It is a string with some restrictions. In this case it should not be empty. We can use
https://kotlinlang.org/docs/inline-classes.html[Kotlin inline classes] to wrap the string without any runtime overhead and
force its validation making the constructor private and exposing the constructor method `of`.

The class `User` is composed by attributes that are not primitives. As a consequence, its constructor become less friendly to use.
That's why we expose a constructor method `of` also for the `User`.

===== Lazy delegated property for the user

If we don't use JPA, we lose some interesting properties. Lazy fetching of relations, for example. That's why in the
constructor of `Article` we don't receive an `Entity<User>`, but a lambda that returns an `Entity<User>` (`<T>` is constraint
of being an `Entity<User>`). The property `author` is a https://kotlinlang.org/docs/delegated-properties.html#lazy-properties[lazy]
delegated property, that executes the lambda only if the property is accessed.

=== Repositories Tests

Testing the repositories doesn't require anything special. Once created an instance of a `Datasource` that points to
an H2, we have to pass it to the constructor of the repositories.

We are going to use https://kotest.io/docs/assertions/assertions.html[Kotest assertions], then add the following dependency:

`build.gradle.kts`

[source,kotlin]
----
testImplementation("io.kotest:kotest-assertions-core-jvm:5.1.0")
----

or if maven

`pom.xml`

[source,xml]
----
<dependency>
    <groupId>io.kotest</groupId>
    <artifactId>kotest-assertions-core-jvm</artifactId>
    <version>5.1.0</version>
</dependency>
----

We will need a Jdbc helper class in order to create tables and doing some quick query. The helper also has a companion object method
`getDataSource` in order to manually instantiate a JdbcDatasource for the tests.

`src/test/kotlin/com/example/blog/JdbcTestsHelper.kt`

[source,kotlin]
----
class JdbcTestsHelper(dataSource: DataSource) {
    companion object{
        val h2Url = "jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE;"

        fun getDataSource(): DataSource = DataSourceBuilder.create()
            .driverClassName("org.h2.Driver")
            .username("sa")
            .password("")
            .url(h2Url)
            .build()
    }

    private val jdbcTemplate = JdbcTemplate(dataSource)

    private val insertUser = SimpleJdbcInsert(dataSource)
        .withTableName("USER")
        .usingGeneratedKeyColumns("id")

    private val insertArticle = SimpleJdbcInsert(dataSource)
        .withTableName("ARTICLE")
        .usingGeneratedKeyColumns("id")

    fun insertUser(user: User): Number = insertUser.executeAndReturnKey(mapOf(
        "login" to user.login.value,
        "firstname" to user.name.firstname,
        "lastname" to user.name.lastname)
    )

    fun insertArticle(article: Article): Number = insertArticle.executeAndReturnKey(mapOf(
        "title" to article.title,
        "headline" to article.headline,
        "content" to article.content,
        "slug" to article.slug,
        "added_at" to article.addedAt,
        "author_id" to article.author.id.value)
    )

    fun createUserTable() = jdbcTemplate.execute(
        """create table if not exists user(
                    id IDENTITY PRIMARY KEY,
                    login VARCHAR NOT NULL,
                    firstname VARCHAR NOT NULL,
                    lastname VARCHAR NOT NULL,
                    description VARCHAR
                )"""
    )

    fun createArticleTable() = jdbcTemplate.execute(
        """create table if not exists article(
                    id IDENTITY PRIMARY KEY,
                    title VARCHAR NOT NULL,
                    headline VARCHAR NOT NULL,
                    content VARCHAR NOT NULL,
                    slug VARCHAR NOT NULL,
                    added_at DATETIME,
                    author_id INT NOT NULL,
                    constraint FK_USER foreign key (author_id) references user(id)
                )"""
    )

    fun dropDb(){
        jdbcTemplate.execute("DROP ALL OBJECTS")
    }
}
----

We will test and implement only the methods that we are going to actually use.
The `UserRepository` and `ArticleRepository` will have the following interfaces

`src/main/kotlin/com/example/blog/repositories.kt`

[source,kotlin]
----
interface UserRepository {
    fun save(user: Entity<User>): UserEntity
    fun findAll(): Collection<UserEntity>
    fun findById(id: Id<Long>): UserEntity?
    fun findByLogin(login: Login): UserEntity?
}

interface ArticleRepository {
    fun save(article: Entity<Article>): ArticleEntity
    fun findAll(): Collection<ArticleEntity>
    fun findAllByOrderByAddedAtDesc(): Collection<ArticleEntity>
    fun findById(id: Id<Long>): ArticleEntity?
    fun findBySlug(slug: String): ArticleEntity?
}
----

Please notice that the repositories `save` methods receive an `Entity` class, while when an Entity is returned, it is always of
type `Entity.WithId`. This is because `save` if both for insert and update, then it can receive either `Entity.New` or
`Entity.WithId`

Then it follows the `UserRepository` tests.

`src/test/kotlin/com/example/blog/UserRepositoriesTests.kt`

[source,kotlin]
----
class UserRepositoriesTests {
    private val dataSource: DataSource = JdbcTestsHelper.getDataSource()

    private val jdbcTemplate = JdbcTemplate(dataSource)
    private val repoHelper = JdbcTestsHelper(dataSource)

    private val userRepository: UserRepository = JdbcUserRepositoryImpl(dataSource)

    private val luca = User.of("springluca", "Luca", "Piccinelli")

    @BeforeEach
    fun setUp() {
        repoHelper.createUserTable()
    }

    @AfterEach
    fun tearDown() {
        repoHelper.dropDb()
    }

    @Test
    fun `When findByLogin then return User`() {
        repoHelper.insertUser(luca)
        val user = userRepository.findByLogin(luca.login)
        user?.info shouldBe luca
    }

    @Test
    fun `When findAll then return a collection of users`() {
        repoHelper.insertUser(luca)
        val users = userRepository.findAll()
        users.map { it.info }.toList() shouldBe listOf(luca)
    }

    @Test
    fun `When saving the user should exist`() {
        val user = userRepository.save(Entity.New(luca))
        val login = getLogin(user)
        user.info.login.value shouldBe login
    }

    @Test
    fun `When updating user its data should change`() {
        val userId = repoHelper.insertUser(luca)

        val newLogin = "banana"
        val user = userRepository.save(Entity.WithId(Id(userId.toLong()), luca.copy(login = Login.of(newLogin))))
        val login = getLogin(user)

        user.info.login.value shouldBe newLogin
        login shouldBe newLogin
    }

    private fun getLogin(user: UserEntity): String =
        jdbcTemplate
            .query("select * from user where id=${user.id.value}") { rs, _ -> rs.getString("login") }
            .first()
}
----

and `ArticleRepositories` tests

`src/test/kotlin/com/example/blog/ArticleRepositoriesTests.kt`

[source,kotlin]
----
class ArticleRepositoriesTests {
    private val dataSource: DataSource = JdbcTestsHelper.getDataSource()

    private val jdbcTemplate = JdbcTemplate(dataSource)
    private val repoHelper = JdbcTestsHelper(dataSource)

    private val articleRepository = JdbcArticleRepositoryImpl(dataSource)

    private val luca = User.of("springluca", "Luca", "Piccinelli")
    private lateinit var article: Article

    @BeforeEach
    internal fun setUp() {
        repoHelper.createUserTable()
        repoHelper.createArticleTable()

        val userId = repoHelper.insertUser(luca)
        article = Article(
            "Spring Kotlin DSL is amazing",
            "Dear Spring community ...",
            "Lorem ipsum",
            { Entity.WithId(Id(userId.toLong()), luca) })
    }

    @AfterEach
    internal fun tearDown() {
        repoHelper.dropDb()
    }

    @Test
    fun `When findBySlug then return Article`() {
        val id = repoHelper.insertArticle(article)
        val articleEntity = articleRepository.findBySlug(article.slug)
        articleEntity?.id?.value shouldBe id.toLong()
    }

    @Test
    fun `When findByAll then return a collection of articles`() {
        val id = repoHelper.insertArticle(article)
        val articles = articleRepository.findAll()
        articles.map { it.id.value }.toList() shouldBe listOf(id.toLong())
    }

    @Test
    fun `When saving the user should exist`() {
        val article = articleRepository.save(Entity.New(article))
        val slug = get(article, "slug")
        article.info.slug shouldBe slug
    }

    @Test
    fun `When updating user its data should change`() {
        val articleId = repoHelper.insertArticle(article)

        val newTitle = "banana"
        val article = articleRepository.save(Entity.WithId(Id(articleId.toLong()), article.copy(title = newTitle)))
        val title = get(article, "title")

        article.info.title shouldBe newTitle
        title shouldBe newTitle
    }

    private fun get(article: ArticleEntity, name: String): String =
        jdbcTemplate
            .query("select * from article where id=${article.id.value}") { rs, _ -> rs.getString(name) }
            .first()
}
----

When using JPA, you test the repositories with `@DataJpaTests`, that requires spring to start. In contrast, the tests above have nothing particular.
At first we instantiate the repositories using the `Datasource` coming from the helper. Then we prepare the database before each test
(see `@BeforeEach`), and we drop everything after each test (see `@AfterEach`), so that each test is actually isolated from the others.

=== The repositories

Finally, the repositories implementations

`src/main/kotlin/com/example/blog/JdbcUserRepositoryImpl.kt`

[source,kotlin]
----
class JdbcUserRepositoryImpl(dataSource: DataSource): UserRepository {

    private val jdbcTemplate = NamedParameterJdbcTemplate(dataSource)

    private val insertUser = SimpleJdbcInsert(dataSource)
        .withTableName("user")
        .usingGeneratedKeyColumns("id")

    override fun findByLogin(login: Login): UserEntity? = firstOrNull("login", login.value)
    override fun findById(id: Id<Long>): UserEntity? = firstOrNull("id", id.value)
    override fun findAll(): Collection<UserEntity> =
        jdbcTemplate.query("select * from user") { rs, _ -> toUser(rs) }

    override fun save(user: Entity<User>): UserEntity = when(user){
        is Entity.New ->{
            insertUser
                .executeAndReturnKey(getUserParameters(user.info))
                .let { id -> Entity.WithId(Id(id.toLong()), user.info) }
        }
        is Entity.WithId -> jdbcTemplate
            .update(
                "update user set login=:login, firstname=:firstname, lastname=:lastname where id=:id",
                getUserParameters(user.info).toMutableMap().also { it["id"] = "${user.id.value}" })
            .let { user }
    }

    private fun getUserParameters(user: User): Map<String, Any> = with(user) {
        mapOf(
            "login" to login.value,
            "firstname" to name.firstname,
            "lastname" to name.lastname
        )
    }

    private fun firstOrNull(paramName: String, value: Any) = jdbcTemplate
        .query("select * from user where $paramName=:$paramName", mapOf(paramName to value)) { rs, _ ->
            toUser(rs)
        }
        .firstOrNull()

    private fun toUser(rs: ResultSet) = Entity.WithId(
        Id(rs.getLong("id")),
        User.of(
            rs.getString("login"),
            rs.getString("firstname"),
            rs.getString("lastname")
        )
    )
}
----

NOTE: Notice in the `save` method how we switch (`when` in Kotlin) between `Entity.New` and `Entity.WithId`. It is
is exhaustive, thanks to the power of sealed classes. That means that the compiler forces use to match every
possible case of the switch, so that nothing unexpected can happen at run-time. The https://kotlinlang.org/docs/typecasts.html#smart-casts[smart cast] do the rest,
so in each branch of the `when` we can access the specialized attributes of each class (e.g. the `id` when updating).

`src/main/kotlin/com/example/blog/JdbcArticleRepositoryImpl.kt`

[source,kotlin]
----
class JdbcArticleRepositoryImpl(dataSource: DataSource): ArticleRepository {
    private val jdbcTemplate = NamedParameterJdbcTemplate(dataSource)
    private val userRepository = JdbcUserRepositoryImpl(dataSource)

    private val insert = SimpleJdbcInsert(dataSource)
        .withTableName("article")
        .usingGeneratedKeyColumns("id")

    override fun findById(id: Id<Long>): ArticleEntity? = firstOrNull("id", id.value)
    override fun findBySlug(slug: String): ArticleEntity? = firstOrNull("slug", slug)
    override fun findAll(): Collection<ArticleEntity> =
        findAll("select * from article")

    override fun findAllByOrderByAddedAtDesc(): Collection<ArticleEntity> =
        findAll("select * from article order by added_at desc")

    override fun save(article: Entity<Article>): ArticleEntity = when (article) {
        is Entity.New -> {
            insert
                .executeAndReturnKey(getArticleParameters(article.info))
                .let { id -> Entity.WithId(Id(id.toLong()), article.info) }
        }
        is Entity.WithId -> jdbcTemplate
            .update(
                """update article set
                    |title=:title,
                    |headline=:headline,
                    |slug=:slug,
                    |added_at=:added_at,
                    |content=:content,
                    |author_id=:author_id
                    |where id=:id""".trimMargin(),
                getArticleParameters(article.info).toMutableMap().also { it["id"] = "${article.id.value}" })
            .let { article }
    }

    private fun getArticleParameters(article: Article): Map<String, Any> = with(article) {
        mapOf(
            "title" to title,
            "headline" to headline,
            "slug" to slug,
            "added_at" to addedAt,
            "content" to content,
            "author_id" to author.id.value,
        )
    }

    private fun toArticle(rs: ResultSet): ArticleEntity {
        val userId = rs.getLong("author_id")
        val articleId = rs.getLong("id")
        return Entity.WithId(
            Id(articleId),
            Article(
                rs.getString("title"),
                rs.getString("headline"),
                rs.getString("content"),
                {
                    userRepository
                        .findById(userId.run(::Id))
                        ?: throw DataRetrievalFailureException("On article with id $articleId There is no user with id $userId")
                },
                rs.getString("slug"),
                rs.getTimestamp("added_at").toLocalDateTime()
            )
        )
    }

    private fun findAll(query: String) =
        jdbcTemplate.query(query) { rs, _ -> toArticle(rs) }

    private fun firstOrNull(parameterName: String, value: Any) = jdbcTemplate
        .query("select * from article where $parameterName=:$parameterName", mapOf(parameterName to value)) { rs, _ ->
            toArticle(rs)
        }
        .firstOrNull()
}
----

=== The Datasource

Our repositories use a `Datasource`. Then we have to create one when starting our application. We are going to use an Hikari datasource
connected to a H2 database.

`src/main/kotlin/com/example/blog/BlogApplication.kt`

[source,kotlin]
----
val h2 = configuration {
    jdbc(DataSourceType.Hikari){
        url = "jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE"
        driverClassName = "org.h2.Driver"
        username = "sa"
        password = ""
    }
}

val app = webApplication {
    enable(h2)
    webMvc {
        mustache{
            prefix = "classpath:/views/"
        }

        router {
            GET("/"){
                ServerResponse.ok()
                    .render("blog", mapOf("title" to "Blog"))
            }
        }
    }
}

fun main(args: Array<String>) {
    app.run(args)
}
----

== Implementing the blog engine

We update the "blog" mustache templates.

