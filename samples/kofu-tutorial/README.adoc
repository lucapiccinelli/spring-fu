:spring-fu-version: 0.5.0
:kofu-kdoc-url: http://repo.spring.io/milestone/org/springframework/fu/spring-fu-kofu/{spring-fu-version}/spring-fu-kofu-{spring-fu-version}-javadoc.jar!

image:https://img.shields.io/badge/KoFu%20documentation-blue.svg["KoFu documentation", link="{kofu-kdoc-url}/kofu/index.html"]

== KoFu DSL for Spring Boot

KoFu (for **Ko**tlin and **Fu**nctional) is an alternative way of configuring explicitly your Spring Boot application,
different from regular auto-configuration, using a Kotlin DSL. It is based on Spring Boot infrastructure, but
https://github.com/spring-projects/spring-fu/tree/main/autoconfigure-adapter[used via functional bean definitions]
instead of JavaConfig.

It leverages other Spring Kotlin DSLs available in Spring like:

* https://docs.spring.io/spring/docs/current/spring-framework-reference/languages.html#kotlin-bean-definition-dsl[`beans { }` DSL] from Spring Framework
* https://docs.spring.io/spring/docs/current/spring-framework-reference/languages.html#router-dsl[`router { }` DSL] from Spring MVC or Spring WebFlux
* https://github.com/spring-projects-experimental/spring-security-kotlin-dsl[`security { }` DSL] (work in progress) from Spring Security

=== Differences with regular Boot applications

- Spring optimizations for native applications are enabled by default
- XML support is disabled by default
- SpEL support is disabled by default
- Devtools automatic restart does not work yet so just restart your applications (very fast with KoFu)

== Content of this tutorial

We are going to build the same blog application as https://spring.io/guides/tutorials/spring-boot-kotlin/[the tutorial for writing Spring Boot applications in Kotlin].

Instead of Spring Data JPA, we are going to use plain JDBC, in order to avoid completely the use of CGLIB.
Writing repositories in plain JDBC requires a consistent extra effort. Fortunately, there exist light ORM like
https://github.com/JetBrains/Exposed[Jetbrains Exposed] or https://www.jooq.org/[Jooq], that are an excellent trade-off
between the productivity of JPA and the readability/testability of plain JDBC. But those are out of the scope of this tutorial.

We will see how KoFu enhances the testability of our code, removing the "magics" of annotations autowiring, and giving you back
the full control of the dependency injection context.

In the end we will see an example of how to plugin-in modules that are not yet fully supported like https://liquibase.org/[Liquibase].

== Getting started
Click https://start.spring.io/#!type=gradle-project&language=kotlin&platformVersion=2.6.3&packaging=jar&jvmVersion=11&groupId=com.example&artifactId=blog&name=blog&description=&packageName=com.example.blog&dependencies=web,mustache,jdbc,h2[here] to go to a preconfigured Spring Initializer

We selected:

1. Gradle (Kotlin DSL) as the build system and Kotlin as language.
2. The latest stable Spring Boot `2.6.x` version (2.6.3 at the moment of writing).
3. Changed the name of artifact to "blog"
4. Jar packaging and Jvm 11 target
5. The following dependencies:
    * Spring Web
    * Mustache
    * Jdbc API
    * H2 in-memory Database

The zip contains a regular spring application template. Unpack and open it with the IDE of your choice (here we are going to use IntelliJ).

=== Modify the Gradle and Maven builds

Go to `build.gradle.kts` (Gradle) or `pom.xml` (Maven). If you don't know their content, you can refer to the sections "Understanding the Gradle Build" or "Understanding the Maven Build" of https://spring.io/guides/tutorials/spring-boot-kotlin/#understanding-generated-app[this] other tutorial.

==== Repositories

Add the spring milestone repository.

===== Gradle

[source,kotlin]
----
repositories {
    maven {
        url = uri("https://repo.spring.io/milestone")
    }
    mavenCentral()
}
----

===== Maven

[source,xml]
----
<repositories>
    <repository>
        <id>spring-milestone</id>
        <name>spring milestone</name>
        <url>https://repo.spring.io/milestone</url>
    </repository>
</repositories>
----

==== Dependencies

Add the Kofu dependency. At the time of writing the latest version of KoFu is the `0.5.0`.

===== Gradle

[source,kotlin]
----
dependencies {
    ...
    implementation("org.springframework.fu:spring-fu-kofu:$kofuVersion")
    ...
}
----

===== Maven

[source,xml]
----
<dependency>
    <groupId>org.springframework.fu</groupId>
    <artifactId>spring-fu-kofu</artifactId>
    <version>${kofu.version}</version>
</dependency>
----

==== Remove plugins (optional)

Let's remove what we don't need anymore. With KoFu, there are no more GCLIB proxies in place, then we don't need to `open` the classes of our beans (classes are `final` by default in Kotlin).

Then we can remove the unnecessary plugins.

===== Gradle

Open  `build.gradle.kts` and remove the following line:

[source,kotlin]
----
kotlin("plugin.spring") version "1.4.32"
----

The plugin section should look like this:

[source,kotlin]
----
plugins {
    id("org.springframework.boot") version "2.6.3"
    id("io.spring.dependency-management") version "1.0.11.RELEASE"
    kotlin("jvm") version "1.6.10"
}
----

===== Maven

Remove the marked lines from your `pom.xml`

[source,xml]
----
<plugins>
  <plugin>
    <groupId>org.jetbrains.kotlin</groupId>
    <artifactId>kotlin-maven-plugin</artifactId>
    <configuration>
      <compilerPlugins>           <!-- REMOVE THIS -->
        <plugin>spring</plugin>   <!-- REMOVE THIS -->
      </compilerPlugins>          <!-- REMOVE THIS -->
      <args>
        <arg>-Xjsr305=strict</arg>
      </args>
    </configuration>
    <dependencies>
      <dependency>                                    <!-- REMOVE THIS -->
        <groupId>org.jetbrains.kotlin</groupId>       <!-- REMOVE THIS -->
        <artifactId>kotlin-maven-allopen</artifactId> <!-- REMOVE THIS -->
        <version>${kotlin.version}</version>          <!-- REMOVE THIS -->
      </dependency>                                   <!-- REMOVE THIS -->
    </dependencies>
  </plugin>
</plugins>
----

The plugin section should look like this:

[source,xml]
----
<plugins>
    <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
    </plugin>
    <plugin>
        <groupId>org.jetbrains.kotlin</groupId>
        <artifactId>kotlin-maven-plugin</artifactId>
        <version>${kotlin.version}</version>
        <configuration>
            <jvmTarget>11</jvmTarget>
            <args>
                <arg>-Xjsr305=strict</arg>
            </args>
        </configuration>
    </plugin>
</plugins>
----

=== Modify The generated application

Go to `BlogApplication.kt` and modify its content as follows:

`src/main/kotlin/com/example/blog/BlogApplication.kt`

[source,kotlin]
----
package com.sample.blog

import org.springframework.fu.kofu.webApplication
import org.springframework.fu.kofu.webmvc.webMvc

val app = webApplication {
    webMvc {
    }
}

fun main(args: Array<String>) {
    app.run(args)
}
----

== Writing your first route

Let's write the routing to display a simple web page

`src/main/kotlin/com/example/blog/BlogApplication.kt`

[source,kotlin]
----
val app = webApplication {
    webMvc {
        mustache()

        router {
            GET("/"){
                ServerResponse.ok()
                    .render("blog", mapOf("title" to "Blog"))
            }
        }
    }
}

fun main(args: Array<String>) {
    app.run(args)
}
----
Notice that the `render` method doesn't use a `Model` class but just a `Map<String, Any>`.

Also, we are explicitly declaring the use of `mustache` through the activation function call. KoFu doesn't start things automatically. We have to
declare it. The cool part is that you can explore all the possible configuration options using the IDE code completion.

image::images/code_completion.png[width=500]

For example, here we see that mustache has two properties: `prefix` and `suffix`, to change the directory of the templates and the templates
extension, respectively. To test this feature, instead of using the default templates folder `classpath:/templates/`, we are going to change
it to `classpath:/views/`

`src/main/kotlin/com/example/blog/BlogApplication.kt`

[source,kotlin]
----
val app = webApplication {
    webMvc {
        mustache{
            prefix = "classpath:/views/"
        }
        ...
    }
}
----

In the `views` folder we create the following template:

`src/main/resources/views/blog.mustache`

[source,html]
----
<html>
    <head>
        <title>{{title}}</title>
    </head>
    <body>
        <h1>{{title}}</h1>
    </body>
</html>
----

Start the web application by running the main function of BlogApplication.kt, and go to http://localhost:8080/,
you should see a sober web page with a "Blog" headline.

== Testing with JUnit5

Compared to regular Spring Boot, where you have to use the annotion `@SpringBootTest`, there is nothing fancy to do
with a KoFu test. You write a normal test, and start/stop spring in the `@BeforeAll` and `@AfterAll`. It is a
regular JUnit test.

`src/test/kotlin/com/example/blog/BlogTests.kt`

[source,kotlin]
----
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class BlogTests {
    lateinit var context: ConfigurableApplicationContext
    lateinit var client: MockMvc

    @BeforeAll
    internal fun setUp() {
        val port = (10000..10500).random()

        context = app.run(arrayOf("--spring.port=${port}"))
        client = MockMvcBuilders
            .webAppContextSetup(context as WebApplicationContext)
            .build()
    }

    @AfterAll
    internal fun tearDown() {
        context.close()
    }

    @Test
    internal fun `Assert blog page title, content and status code`() {
        client.get("/")
            .andExpect {
                status { isOk() }
                content {
                    string(Matchers.containsString("<h1>Blog</h1>"))
                }
            }
    }
}
----

There is no magic here. Everything is transparent.

`@TestInstance(TestInstance.Lifecycle.PER_CLASS)` is related to JUnit 5, you
probably already know what it is if you use JUnit 5. https://www.baeldung.com/junit-testinstance-annotation[It is needed to use `@BeforeAll` and `@AfterAll`] annotations.
You can change the tests instances lyfe cycle also project-wise if you like it, as described https://github.com/spring-guides/tut-spring-boot-kotlin#test-instance-lifecycle[here].
I would not suggest of doing it.

In the `@BeforeAll` we start Spring on a random port and use the application context to create the MockMvc, so that
it points to correct port.

We then use the `client` to perform the http requests in the test and verify the result. More on MockMvc https://www.baeldung.com/integration-testing-in-spring[here].

== Write some extension utilities

We are going to write some extension utilities that we will use in the next section.

`src/main/kotlin/com/example/blog/extensions.kt`

[source,kotlin]
----
fun LocalDateTime.format(): String = this.format(englishDateFormatter)

private val daysLookup = (1..31).associate { it.toLong() to getOrdinal(it) }

private val englishDateFormatter = DateTimeFormatterBuilder()
    .appendPattern("yyyy-MM-dd")
    .appendLiteral(" ")
    .appendText(ChronoField.DAY_OF_MONTH, daysLookup)
    .appendLiteral(" ")
    .appendPattern("yyyy")
    .toFormatter(Locale.ENGLISH)

private fun getOrdinal(n: Int) = when {
    n in 11..13 -> "${n}th"
    n % 10 == 1 -> "${n}st"
    n % 10 == 2 -> "${n}nd"
    n % 10 == 3 -> "${n}rd"
    else -> "${n}th"
}

fun String.toSlug() = lowercase()
    .replace("\n", " ")
    .replace("[^a-z\\d\\s]".toRegex(), " ")
    .split(" ")
    .joinToString("-")
    .replace("-+".toRegex(), "-")
----

== Persistence with JDBC

KoFu doesn't make use of CGLIB. This means that we have to write our repository and map our entities manually. This is not necessarily a bad thing: if you implement
the https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html[Clean Architecture], you are going to map your entities anyway. Also mastering JPA
implementations, like the one provided by Hibernate is not easy like it seems.

Also, ORM frameworks forces you to model your entities as a 1:1 mapping of the E/R schema of the database. This could lead to design problems like:

 * http://hibernate.org/orm/what-is-an-orm/[Object-Relational impedance mismatch]
 * https://martinfowler.com/bliki/AnemicDomainModel.html[Anemic Domain Model]
 * https://refactoring.guru/smells/primitive-obsession[Primitive obsession coding smell]

Let's model our domain entities at first:

=== Domain Entities

`src/main/kotlin/com/example/blog/entities.kt`

[source,kotlin]
----
sealed class Entity<out T>(open val info: T){
    data class WithId<out T>(val id: Id<Long>, override val info: T) : Entity<T>(info)
    data class New<out T>(override val info: T) : Entity<T>(info)
}

data class Id<T>(val value: T)

data class Name(
    val firstname: String,
    val lastname: String,
)

@JvmInline
value class Login private constructor(val value: String){
    companion object{
        fun of(value: String): Login{
            require(value.isNotEmpty()){ "can't accept an empty login value" }
            return Login(value)
        }
    }
}

data class User(
    val login: Login,
    val name: Name,
    val description: String? = null){

    companion object{
        fun of(
            login: String,
            firstname: String,
            lastname: String,
            description: String? = null) =
            User(Login.of(login), Name(firstname, lastname), description)
    }
}

data class Article<out T : Entity<User>>(
    val title: String,
    val headline: String,
    val content: String,
    private val authorFn: () -> T,
    val slug: String = title.toSlug(),
    val addedAt: LocalDateTime = LocalDateTime.now().withNano(0)
){
    val author by lazy(authorFn)
}
----

Here we used some of the many nice features of Kotlin.

===== Sealed class for the Entity

When you use a repository to save an entity, you usually don't make distinction beetween saving something new or doing an update.
This is a responsibility of the repository. Also, it happens many times that you want the persistence layer to give you
back a generated ID. There exist some strategies to model this: the most naive is to reserve some values (like 0 or negatives) to
express the intent of requesting a generated ID.

This is a perfect use-case for the https://kotlinlang.org/docs/sealed-classes.html[sealed classes] of Kotlin. We use a generic `Entity<T>`
class that is inherited by `Entity<T>.New` and `Entity<T>.WithId`. Then you can say that a repository accepts an `Entity<T>` when it
comes to the `save` method, and it returns an `Entity<T>.WithId` for the `get/find` methods. Internally the `save` method will check
statically if we are saving something new or to update.

===== Value class and companion objects for the Login and the User

A login value is not just a string. It is a string with some restrictions. In this case it should not be empty. We can use
https://kotlinlang.org/docs/inline-classes.html[Kotlin inline classes] to wrap the string without any runtime overhead and
force its validation making the constructor private and exposing the constructor method `of`.

The class `User` is composed by attributes that are not primitives. As a consequence, its constructor become less friendly to use.
That's why we expose a constructor method `of` also for the `User`.

===== Lazy delegated property for the user

If we don't use JPA, we lose some interesting properties. Lazy fetching of relations, for example. That's why in the
constructor of `Article` we don't receive an `Entity<User>`, but a lambda that returns an `Entity<User>` (`<T>` is constraint
of being an `Entity<User>`). The property `author` is a https://kotlinlang.org/docs/delegated-properties.html#lazy-properties[lazy]
delegated property, that executes the lambda only if the property is accessed.

=== Repositories Tests

Testing the repositories doesn't require anything special. Once we have created an instance of a `Datasource` that points to
an H2, we just have to pass it to the constructor of the repositories.